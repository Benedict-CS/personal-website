# 個人網站架構演進：從 Stateless 到 RustFS 的心路歷程

> 記錄個人網站從無狀態設計到使用物件儲存，歷經 MinIO、SeaweedFS，最終選擇 RustFS 的完整過程

## 起點：Stateless 設計的挑戰

### 最初的架構

一開始，我的個人網站採用「stateless」設計理念：
- 所有資料都儲存在資料庫中
- 圖片直接嵌入在文章內容中（base64 或直接 URL）
- 沒有獨立的媒體儲存系統

### 遇到的問題

1. **資料庫膨脹**：圖片以 base64 編碼儲存在資料庫，導致資料庫檔案快速增長
2. **效能問題**：每次載入文章都要從資料庫讀取大量圖片資料
3. **維護困難**：無法獨立管理媒體檔案
4. **擴展性差**：無法有效處理大量圖片

## 第一次演進：引入 MinIO

### 為什麼選擇 MinIO？

在 2024 年，MinIO 是最受歡迎的開源 S3-compatible 物件儲存解決方案：
- ✅ 完整的 S3 API 相容性
- ✅ 簡單的 Docker 部署
- ✅ 活躍的開發社群
- ✅ 豐富的文件

### 架構改變

```
Before (Stateless):
User → Next.js → PostgreSQL (包含圖片 base64)

After (MinIO):
User → Next.js → PostgreSQL (文章) + MinIO (圖片)
```

### 實作過程

1. **加入 MinIO 服務**：
   ```yaml
   minio:
     image: minio/minio:latest
     ports:
       - "9000:9000"
   ```

2. **使用 AWS S3 SDK**：
   - 使用 `@aws-sdk/client-s3` 作為通用介面
   - 這樣設計的好處是未來可以輕鬆切換到其他 S3-compatible 服務

3. **建立上傳 API**：
   - `/api/upload` - 處理圖片上傳
   - `/api/media/serve/[filename]` - 提供圖片服務

### 解決的問題

- ✅ 資料庫大小大幅減少
- ✅ 圖片載入效能提升
- ✅ 可以獨立管理媒體檔案
- ✅ 支援圖片清理功能

## 轉折點：MinIO 進入維護模式

### 2025年12月的消息

MinIO 官方宣布進入維護模式：
- ⚠️ 不再開發新功能
- ⚠️ 只修復關鍵安全問題
- ⚠️ 不再發布新的 Docker 映像

### 我的考量

作為個人專案，我面臨選擇：
1. **繼續使用 MinIO**：目前穩定，但長期有風險
2. **遷移到替代方案**：需要時間，但更符合長期規劃

### 第一次嘗試：SeaweedFS

經過評估，我首先嘗試了 **SeaweedFS**：

**優點**：
- ✅ Apache 2.0 授權（比 MinIO 的 AGPLv3 更寬鬆）
- ✅ 分散式架構，可擴展性強
- ✅ 活躍的開發社群（GitHub 20k+ stars）
- ✅ 完整的 S3 API 相容性

**遇到的問題**：
- ❌ 需要多個服務（master, volume, filer, s3）- 複雜度高
- ❌ 磁碟空間要求嚴格（至少 1% 可用空間）
- ❌ 遷移困難（需要遷移多個服務的數據）
- ❌ 在資源受限的環境下運行困難

## 第二次演進：嘗試 SeaweedFS（但遇到問題）

### 遷移過程

### SeaweedFS 的挑戰

雖然 SeaweedFS 功能強大，但在實際部署中遇到了問題：

1. **複雜的架構**：需要 4 個服務協同工作
2. **磁碟空間限制**：系統要求至少 1% 可用空間，但在資源受限的環境中難以滿足
3. **遷移困難**：需要遷移 master、volume、filer 等多個服務的數據

這些問題讓我重新思考：對於個人網站，是否真的需要如此複雜的分散式架構？

## 第三次演進：選擇 RustFS

### 為什麼最終選擇 RustFS？

在嘗試 SeaweedFS 後，我發現了 **RustFS**：

**RustFS 的優勢**：
- ✅ **2.3x 比 MinIO 更快**（4KB 對象測試）
- ✅ **Apache 2.0 授權**（商業友好，無 AGPL 限制）
- ✅ **單一服務**（比 SeaweedFS 簡單得多）
- ✅ **100% S3 兼容**（無縫遷移）
- ✅ **內存安全**（Rust 編寫）
- ✅ **強大的 Console**（比 MinIO 更好的管理界面）
- ✅ **活躍開發**（GitHub 20k+ stars，持續更新）

**遷移到 RustFS**：

```yaml
# 簡單的單一服務配置
rustfs:
  image: rustfs/rustfs:latest
  ports:
    - "9000:9000"  # S3 API
    - "9001:9001"  # Console
  volumes:
    - ./rustfs-data:/data
    - ./rustfs-logs:/logs
```

### 關鍵設計決策

**使用標準 S3 API 的優勢**：

從一開始就使用 AWS S3 SDK 的設計決策，讓所有遷移都變得非常簡單：
- ✅ **不需要修改任何程式碼**：`src/lib/s3.ts` 只需要更新 endpoint 和註釋
- ✅ **只需要更新配置**：修改 `docker-compose.yml` 和環境變數
- ✅ **資料遷移簡單**：使用標準工具（rclone）即可

這證明了**抽象層設計的重要性**。

## 學到的經驗

### 1. 抽象層設計的重要性

使用標準 S3 API 而非 MinIO 專屬 API，讓遷移成本降到最低。

### 2. 關注開源專案的長期維護

MinIO 進入維護模式提醒我們：
- 定期關注依賴專案的狀態
- 評估授權條款的影響
- 準備替代方案

### 3. 文檔的重要性

完整的文檔讓遷移過程變得順暢：
- 記錄每個決策的原因
- 記錄遷移步驟
- 記錄遇到的問題和解決方案

## 現在的架構

```
┌─────────────────┐
│   Web Browser   │
└────────┬────────┘
         │
         ↓
┌─────────────────┐
│  Next.js App    │
│  (Port 3000)    │
└──────┬──────────┘
       │
   ┌───┴──────────────┐
   ↓                   ↓
┌──────┐    ┌──────────────────┐
│Postgres│   │     RustFS       │
│ :5432  │   │  :9000 (S3 API)  │
└──────┘    │  :9001 (Console) │
            └──────────────────┘
```

## 演進總結

### Stateless → MinIO → SeaweedFS → RustFS

1. **Stateless**：簡單但不可擴展
2. **MinIO**：穩定但進入維護模式
3. **SeaweedFS**：功能強大但過於複雜
4. **RustFS**：簡單、快速、現代 ✅

### 學到的經驗

1. **抽象層設計的重要性**：使用標準 S3 API 讓遷移成本降到最低
2. **簡單性優先**：對於個人網站，簡單的單一服務比複雜的分散式架構更合適
3. **關注開源專案的長期維護**：定期評估依賴專案的狀態
4. **效能很重要**：RustFS 的 2.3x 效能提升是實質的優勢
5. **授權條款很重要**：Apache 2.0 比 AGPLv3 更適合商業使用

## 未來規劃

1. **監控 RustFS 的發展**：確保它持續活躍
2. **優化效能**：根據實際使用情況調整配置
3. **探索分散式部署**：如果未來需要，RustFS 也支援多節點
4. **定期備份**：確保數據安全

## 結論

從 stateless 到 MinIO，再到 SeaweedFS，最終選擇 RustFS，這個過程讓我學到：
- 架構設計要考慮未來變化
- 使用標準介面（S3 API）的重要性
- **簡單性往往比複雜性更好**
- 開源專案的長期維護需要關注
- 完整的文檔是無價的

**關鍵啟示**：
1. 好的抽象層設計，讓技術棧的切換變得簡單
2. 對於個人專案，簡單的解決方案通常是最佳選擇
3. 效能和授權條款同樣重要

---

*最後更新：2025年1月*
